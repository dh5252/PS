# [Silver I] 심심한 준규 - 2892 

[문제 링크](https://www.acmicpc.net/problem/2892) 

### 성능 요약

메모리: 2024 KB, 시간: 0 ms

### 분류

애드 혹, 비트마스킹

### 문제 설명

<p>해빈이는 준규에게 메세지를 받았다. 준규는 세계 최고 수준의 암호학자이기 때문에 해빈이에게 암호로 메세지를 보낸다. 이번에 준규는 One Time Pad(OTP) 암호화 방식을 사용하기로 했다. 준규는 OTP방식을 제대로 적용하면 절대 해독할 수 없다는 것을 알기 때문에, 해빈이가 해석할 수 있도록 몇 가지 힌트를 같이 보내기로 했다.</p>

<p>준규는 메세지에 항상 영소문자, 온점('.'), 공백 (' ', ASCII코드 32)만 쓴다. 그리고 key값으로는 항상 '0'부터 '9'까지의 숫자만 쓴다. 이 사실을 알고 있는 해빈이는 이를 이용해 메세지에 있는 온점과 공백의 위치를 알 수 있다는 것을 깨닫고, 당신에게 프로그램으로 만들어달라고 부탁했다.</p>

<p>준규가 이런 메세지를 보낸 게 한두 번이 아니기 때문에 해빈이는 OTP 암호화 방식을 알고 있다. 예를 들어 "0120123"을 key로 사용해서 "abc efg"라는 문자열을 암호화하면 아래와 같다.</p>

<table class="table table-bordered td-center th-center">
	<tbody>
		<tr>
			<td>
			<pre>abc efg
0120123</pre>
			</td>
			<td>
			<pre>61 62 63 20 65 66 67
30 31 32 30 31 32 33</pre>
			</td>
			<td>
			<pre>51 53 51 10 54 54 54</pre>
			</td>
		</tr>
	</tbody>
	<tfoot>
		<tr>
			<th>Start</th>
			<th>ASCII hexadecimal</th>
			<th>excrypted message</th>
		</tr>
	</tfoot>
</table>

<p>먼저 key와 메세지 원문을 ASCII 인코딩을 사용해 16진수로 변환한다. 그리고 변환한 key와 원문을 각각 차례대로 XOR 연산한다. 그 결과가 암호화 된 메세지이다.</p>

### 입력 

 <p>입력에 첫 줄에는 암호화 된 메세지의 길이인 정수 N (1 ≤ N ≤ 1000)이 주어진다.</p>

<p>다음 줄에는 암호화 된 메세지가 N개의 16진수 정수로 주어진다. 이 수는 0(10진수) 이상 127(10진수) 이하이다.</p>

### 출력 

 <p>N개의 문자를 한 줄에 출력한다. 만약 i번째 글자가 문자라면 '-'를, 아니라면 '.'을 출력한다.</p>

